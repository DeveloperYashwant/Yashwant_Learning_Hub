### Lecture 10: **Deployment with Docker and Kubernetes**

---

#### **1. Introduction to Deployment**

Deployment is the process of moving code from a local development environment to a production environment. For modern microservices applications, **Docker** and **Kubernetes** are the most widely used tools for packaging, distributing, and managing the deployment of applications.

- **Docker** allows applications to be packaged in containers, which include all dependencies and can be run consistently across different environments.
- **Kubernetes** is a container orchestration platform that helps you manage, scale, and monitor containers running on a cluster of machines.

In this lecture, we will look at how to deploy Spring Boot applications using **Docker** and **Kubernetes**.

---

#### **2. Docker: Containerizing Spring Boot Applications**

##### **2.1 What is Docker?**

**Docker** is an open-source platform that automates the deployment of applications inside lightweight, portable containers. A Docker container includes everything needed to run the application: the code, runtime, libraries, and system tools.

##### **2.2 Steps to Dockerize a Spring Boot Application**

**Step 1: Create a Spring Boot Application**

For this example, let’s assume you have a simple Spring Boot application like the `ProductService`.

```java
package com.example.productservice;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class ProductController {

    @GetMapping("/products")
    public String getProducts() {
        return "List of products";
    }
}
```

**Step 2: Create a Dockerfile**

The Dockerfile defines the steps to build a Docker image for your Spring Boot application.

Create a `Dockerfile` in the root of your Spring Boot project:

```dockerfile
# Use an official OpenJDK image as a parent image
FROM openjdk:11-jdk-slim

# Set the working directory in the container
WORKDIR /app

# Copy the jar file from the target directory to the container
COPY target/product-service.jar /app/product-service.jar

# Expose the application port
EXPOSE 8080

# Run the Spring Boot application
ENTRYPOINT ["java", "-jar", "/app/product-service.jar"]
```

- The `FROM` directive specifies the base image (an OpenJDK 11 image).
- The `COPY` directive copies the Spring Boot `.jar` file (generated by running `mvn clean package`) into the Docker container.
- The `EXPOSE` directive opens port `8080`, which is the port the Spring Boot application will listen to.
- The `ENTRYPOINT` directive specifies the command to run the application inside the container.

**Step 3: Build the Docker Image**

To build the Docker image, run the following command in your project root directory:

```bash
docker build -t product-service .
```

This command tells Docker to build the image using the `Dockerfile` in the current directory and tag it as `product-service`.

**Step 4: Run the Docker Container**

To run the application inside a Docker container, use the following command:

```bash
docker run -p 8080:8080 product-service
```

This command starts the container and maps port `8080` on your host to port `8080` in the container, allowing you to access the application at `http://localhost:8080/products`.

---

#### **3. Introduction to Kubernetes**

##### **3.1 What is Kubernetes?**

**Kubernetes** is an open-source platform for automating container orchestration. It helps you manage, scale, and deploy containerized applications. Kubernetes abstracts away the complexity of deploying and managing containers in large-scale environments.

Key concepts in Kubernetes:
- **Pod**: A group of one or more containers deployed together.
- **Service**: An abstraction layer for exposing pods to the network.
- **Deployment**: A Kubernetes object that ensures a specified number of pod replicas are running.
- **Namespace**: A way to divide resources into logical groups within a Kubernetes cluster.

##### **3.2 Setting Up a Kubernetes Cluster**

To start working with Kubernetes, you’ll need a Kubernetes cluster. You can set up a cluster using tools like **Minikube** (for local environments) or **Google Kubernetes Engine (GKE)**.

For local development, you can use **Minikube** to spin up a local Kubernetes cluster on your machine.

1. **Install Minikube**:
   Follow the instructions for your operating system from the [Minikube website](https://minikube.sigs.k8s.io/docs/).

2. **Start Minikube**:

```bash
minikube start
```

3. **Verify Minikube is Running**:

```bash
kubectl cluster-info
```

---

#### **4. Deploying Spring Boot Application to Kubernetes**

##### **4.1 Create Kubernetes Deployment YAML File**

To deploy a Spring Boot application to Kubernetes, you need to define a Kubernetes `Deployment` and `Service`. The `Deployment` specifies how many replicas of the application should be running, and the `Service` exposes the application to the network.

Create a file named `product-service-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: product-service
  template:
    metadata:
      labels:
        app: product-service
    spec:
      containers:
        - name: product-service
          image: product-service:latest
          ports:
            - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  selector:
    app: product-service
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
  type: LoadBalancer
```

- **Deployment**: The `Deployment` will ensure that there are 3 replicas of the `product-service` container running.
- **Service**: The `Service` exposes the application and directs traffic to port `8080`.

##### **4.2 Apply the Kubernetes Configuration**

Once you have your Kubernetes configuration file ready, apply it using `kubectl`:

```bash
kubectl apply -f product-service-deployment.yaml
```

This command will create the deployment and service in your Kubernetes cluster.

##### **4.3 Access the Application**

To access the application, use the `kubectl` command to expose the service:

```bash
kubectl expose deployment product-service --type=LoadBalancer --name=product-service
```

If you are using Minikube, you can access the service via:

```bash
minikube service product-service
```

This command will open a browser with the URL to access your service running on Kubernetes.

---

#### **5. Monitoring and Scaling the Application**

##### **5.1 Scaling the Application**

To scale the number of replicas in your deployment, you can use the following `kubectl` command:

```bash
kubectl scale deployment product-service --replicas=5
```

This command will scale the `product-service` deployment to 5 replicas, ensuring high availability.

##### **5.2 Monitoring the Application**

You can monitor the status of your Kubernetes deployment with:

```bash
kubectl get deployments
kubectl get pods
```

These commands show the current status of your deployments and pods.

---

#### **6. Conclusion**

In this lecture, we covered the following:

- **Docker**: How to containerize a Spring Boot application using a Dockerfile and deploy it locally.
- **Kubernetes**: An introduction to Kubernetes and how to deploy your Spring Boot application using Kubernetes with a `Deployment` and `Service`.
- **Scaling and Monitoring**: How to scale the application and monitor its status within Kubernetes.

