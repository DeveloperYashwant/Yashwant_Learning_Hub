
## **Node.js – Lecture 3: Node.js Modules**

### 1️ **What Are Modules?**

* A **module** is simply a file containing JavaScript code that can be **imported** into other files.
* Modules let you **organize**, **reuse**, and **encapsulate** functionality.
* Every file in Node.js is treated as its own module.

---

### 2️ **Built-in Modules**

Node.js comes with a rich set of modules you can use without installing anything extra. Let’s look at three of the most common ones:

####  **`fs` (File System)**

* Used to **read**, **write**, **update**, and **delete** files.
* **Example** – read a file asynchronously:

 javascript
  const fs = require('fs');

  fs.readFile('notes.txt', 'utf8', (err, data) => {
    if (err) return console.error(err);
    console.log(data);
  });
 

#### **`path`**

* Helps you work with **file and directory paths** in a safe, cross-platform way.
* **Example** – combine path segments:

  javascript
  const path = require('path');

  const fullPath = path.join(__dirname, 'data', 'info.json');
  console.log(fullPath);
  
  
  //Pending Notes  (Commands)

#### **`os`**

* Provides information about the **operating system** your code is running on.
* **Example** – get free memory:

  javascript
  const os = require('os');

  console.log(`Free memory: ${os.freemem()} bytes`);
  

---

### 3️ **Creating and Using Your Own Module**

1. **Create a file** called `math.js`:

   javascript
   // math.js
   function add(a, b) {
     return a + b;
   }

   function multiply(a, b) {
     return a * b;
   }

   // Export the functions
   module.exports = {
     add,
     multiply
   };
   
2. **Import** and **use** it in another file, `app.js`:

   javascript
   // app.js
   const math = require('./math');

   console.log(math.add(2, 3));       // 5
   console.log(math.multiply(4, 5));  // 20
   

---

### 4️**Using `require` and `exports`**

* **`require('module-name')`**

  * Synchronously loads a module (built-in, third-party, or local).
  * Returns the module’s `module.exports` object.

* **`module.exports`**

  * The object that your module **exposes** to code that `require`s it.

* **`exports` shortcut**

  javascript
  // Equivalent to module.exports.foo = foo;
  exports.foo = function foo() { … };
  

**Tip:** Don’t reassign `exports` directly (e.g. `exports = {...}`); always modify its properties, or assign the full export object to `module.exports`.

---

###  **Why Modules Matter (Importance & Interest)**

1. **Separation of Concerns**

   * Break your application into **logical pieces** (database access, utilities, routing, etc.).
2. **Reusability**

   * Write a piece of code **once** and reuse it across your project (or even across projects).
3. **Maintainability**

   * Smaller files with focused functionality are **easier to read**, **test**, and **debug**.
4. **Encapsulation**

   * Modules keep variables and functions **private** unless you explicitly export them.
5. **Community Ecosystem**

   * The npm registry is a massive collection of **third-party modules** you can `require` with zero setup.

---

**Next Steps / Practice:**

* Build a small utility module (e.g., a date formatter) and import it into a demo script.
* Experiment with additional built-in modules like `http` to see how modules power Node.js’s core capabilities.
